generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Farmer {
  id    String  @id @default(uuid())
  phone String? @unique
  email String? @unique

  location String?
  province String?
  district String?
  sector   String?
  cell     String?
  village  String?

  locationUpdatedAt DateTime?

  role              Role    @default(FARMER)
  preferredLanguage String? @default("KINY")
  password          String?

  phoneVerified  Boolean   @default(false)
  phoneChangedAt DateTime?

  accountLocked Boolean   @default(false)
  lockedUntil   DateTime?
  pinChangedAt  DateTime?

  smsNotifications      Boolean @default(false)
  notificationFrequency String?

  createdAt              DateTime                 @default(now())
  updatedAt              DateTime                 @updatedAt
  submissions            FarmerSubmission[]
  FarmerSecurityEvent    FarmerSecurityEvent[]
  FarmerSecurityQuestion FarmerSecurityQuestion[]
  FarmerLoginAttempt     FarmerLoginAttempt[]
  FarmerSecurityAlert    FarmerSecurityAlert[]
  FarmerProfile          FarmerProfile?
  FarmerPrimaryCrop      FarmerPrimaryCrop[]
  SupportTicket          SupportTicket[]
  CallbackRequest        CallbackRequest[]
}

model Restaurant {
  id    String  @id @default(uuid())
  name  String
  email String  @unique
  phone String? @unique

  location String?
  province String?
  district String?
  sector   String?
  cell     String?
  village  String?

  password String
  role     Role   @default(RESTAURANT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  orders        Order[]
  posSales      POSSale[]
  Cart          Cart[]
  Wallet        Wallet?
  subscriptions RestaurantSubscription[]
}

model FarmerSubmission {
  id                   String                @id @default(uuid())
  farmerId             String
  productName          String
  submittedQty         Float?
  acceptedQty          Float?
  totalAmount          Float?
  categoryId           String?
  status               SubmissionStatus      @default(PENDING)
  farmerFeedbackStatus FarmerFeedbackStatus? @default(PENDING)
  farmerFeedbackAt     DateTime?
  farmerFeedbackNotes  String?
  farmerCounterOffer   Float? // If farmer wants different price
  farmerCounterQty     Float? // If farmer wants different quantity
  feedbackDeadline     DateTime? // Deadline for farmer response
  aggregatorId         String?
  submittedAt          DateTime              @default(now())
  verifiedAt           DateTime?
  paymentMethod        PaymentMethod?
  approvedAt           DateTime?
  paidAt               DateTime?
  acceptedPrice        Float?
  approvedProductId    String?
  wishedPrice          Float?

  location String?
  province String?
  district String?
  sector   String?
  cell     String?
  village  String?

  approvedProduct Product?         @relation(fields: [approvedProductId], references: [id])
  farmer          Farmer           @relation(fields: [farmerId], references: [id])
  aggregator      Admin?           @relation("Aggregator", fields: [aggregatorId], references: [id])
  category        ProductCategory? @relation(fields: [categoryId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model FarmerSecurityEvent {
  id          String   @id @default(uuid())
  farmerId    String
  eventType   String // PIN_CHANGE, PHONE_CHANGE, LOGIN_ATTEMPT, etc.
  description String?
  ipAddress   String?
  deviceInfo  String?
  createdAt   DateTime @default(now())

  farmer Farmer @relation(fields: [farmerId], references: [id])

  @@index([farmerId])
  @@index([eventType])
}

model FarmerSecurityQuestion {
  id         String   @id @default(uuid())
  farmerId   String
  question   String
  answerHash String
  createdAt  DateTime @default(now())

  farmer Farmer @relation(fields: [farmerId], references: [id])

  @@index([farmerId])
}

model FarmerLoginAttempt {
  id          String   @id @default(uuid())
  farmerId    String
  successful  Boolean
  attemptTime DateTime
  deviceInfo  String?

  farmer Farmer @relation(fields: [farmerId], references: [id])

  @@index([farmerId])
  @@index([attemptTime])
}

model FarmerSecurityAlert {
  id          String   @id @default(uuid())
  farmerId    String
  alertType   String
  description String
  severity    String // LOW, MEDIUM, HIGH, CRITICAL
  resolved    Boolean  @default(false)
  createdAt   DateTime @default(now())

  farmer Farmer @relation(fields: [farmerId], references: [id])

  @@index([farmerId])
  @@index([severity])
}

model FarmerProfile {
  id                     String   @id @default(uuid())
  farmerId               String   @unique
  farmSize               Float?
  farmSizeUnit           String? // HECTARES, ACRES
  experienceYears        Int?
  cooperativeMember      Boolean?
  cooperativeName        String?
  certifications         String[]
  farmingMethod          String? // ORGANIC, CONVENTIONAL, MIXED
  preferredPaymentMethod String? // MOBILE_MONEY, BANK_TRANSFER, CASH
  minimumOrderQuantity   Float?
  deliveryPreference     String? // FARM_PICKUP, COOPERATIVE_CENTER, MARKET_DELIVERY
  maxDeliveryDistance    Float?
  defaultLocation        Json?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  farmer Farmer @relation(fields: [farmerId], references: [id])

  @@index([farmerId])
}

model FarmerPrimaryCrop {
  id              String   @id @default(uuid())
  farmerId        String
  productId       String
  seasonal        Boolean  @default(false)
  defaultQuantity Float
  harvestMonths   String[]
  createdAt       DateTime @default(now())

  farmer  Farmer  @relation(fields: [farmerId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  @@index([farmerId])
  @@index([productId])
}

model SupportTicket {
  id           String   @id @default(uuid())
  ticketNumber String   @unique
  farmerId     String
  category     String // TECHNICAL, PAYMENT, ACCOUNT, GENERAL
  description  String
  priority     String // LOW, MEDIUM, HIGH, URGENT
  status       String   @default("OPEN") // OPEN, IN_PROGRESS, RESOLVED, CLOSED
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  farmer    Farmer            @relation(fields: [farmerId], references: [id])
  responses SupportResponse[]

  @@index([farmerId])
  @@index([status])
  @@index([ticketNumber])
}

model SupportResponse {
  id        String   @id @default(uuid())
  ticketId  String
  message   String
  isStaff   Boolean  @default(false)
  createdAt DateTime @default(now())

  ticket SupportTicket @relation(fields: [ticketId], references: [id])

  @@index([ticketId])
}

model CallbackRequest {
  id            String   @id @default(uuid())
  farmerId      String
  phoneNumber   String
  preferredTime String
  issue         String
  status        String   @default("PENDING") // PENDING, SCHEDULED, COMPLETED
  createdAt     DateTime @default(now())

  farmer Farmer @relation(fields: [farmerId], references: [id])

  @@index([farmerId])
  @@index([status])
}

model Admin {
  id        String   @id @default(uuid())
  username  String
  email     String   @unique
  password  String
  role      Role
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  phone String? @unique

  location String?
  province String?
  district String?
  sector   String?
  cell     String?
  village  String?

  aggregatorAssignments FarmerSubmission[] @relation("Aggregator")
  logisticsAssignments  Order[]            @relation("LOGISTICS")
  products              Product[]
  productCategories     ProductCategory[]
}

model Product {
  id                String              @id @default(uuid())
  unitPrice         Float
  purchasePrice     Float
  unit              String
  createdAt         DateTime            @default(now())
  bonus             Int
  createdBy         String
  expiryDate        DateTime?
  images            String[]
  quantity          Float
  sku               String              @unique
  updatedAt         DateTime            @updatedAt
  categoryId        String
  productName       String              @unique
  status            ProductStatus       @default(ACTIVE)
  province          String?
  district          String?
  sector            String?
  cell              String?
  village           String?
  farmerSubmissions FarmerSubmission[]
  orderItems        OrderItem[]
  admin             Admin               @relation(fields: [createdBy], references: [id])
  CartItem          CartItem[]
  category          ProductCategory     @relation(fields: [categoryId], references: [id])
  FarmerPrimaryCrop FarmerPrimaryCrop[]
}

model ProductCategory {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String

  // Relations
  admin             Admin              @relation(fields: [createdBy], references: [id])
  products          Product[]
  farmerSubmissions FarmerSubmission[]

  @@index([name])
  @@index([isActive])
}

// Cart schema model - Prisma Schema for Cart Management
model Cart {
  id           String     @id @default(uuid())
  restaurantId String // Foreign key to Restaurant model
  totalAmount  Float      @default(0) // Total amount of all items in cart
  status       CartStatus @default(ACTIVE) // Cart status (ACTIVE, CHECKED_OUT, ABANDONED)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  cartItems  CartItem[] // One cart can have many cart items
  orders     Order[] // Cart can have multiple orders created from it

  // Indexes for better performance
  @@index([restaurantId])
  @@index([status])
}

// Cart Item model to store individual items in the cart
model CartItem {
  id        String   @id @default(uuid())
  cartId    String // Foreign key to Cart model
  productId String // Foreign key to Product model
  quantity  Float // Quantity of the product
  unitPrice Float // Price per unit at the time of adding to cart
  subtotal  Float // quantity * unitPrice
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Ensure unique product per cart (restaurant can't add same product multiple times)
  @@unique([cartId, productId])
  @@index([cartId])
  @@index([productId])
}

// ORDER model 
model Order {
  id           String      @id @default(uuid())
  restaurantId String
  logisticsId  String?
  orderNumber  String      @unique
  status       OrderStatus @default(PENDING)
  totalAmount  Float

  // Cart reference 
  cartId String?

  // Billing information 
  billingName    String?
  billingEmail   String?
  billingPhone   String?
  billingAddress String?

  // Order notes and dates
  notes             String?
  requestedDelivery DateTime?
  estimatedDelivery DateTime?
  actualDelivery    DateTime?

  // Payment information
  paymentMethod    PaymentMethod?
  paymentStatus    PaymentStatus  @default(PENDING)
  paymentReference String?
  paymentProvider  String?        @default("FLUTTERWAVE")
  paymentType      String?

  // Enhanced Payment Fields 
  txRef             String? @unique
  flwRef            String?
  txOrderId         String?
  currency          String? @default("RWF")
  clientIp          String?
  deviceFingerprint String?
  narration         String?

  // Bank transfer specific fields
  transferReference String?
  transferAccount   String?
  transferBank      String?
  transferNote      String?
  transferAmount    Float?

  // Mobile money specific fields
  network String? // Network provider (MTN, Airtel, etc.)
  voucher String? // Voucher code

  // Card payment specific fields
  cardNumber      String?
  cardCVV         String?
  cardType        String?
  cardExpiryMonth String?
  cardExpiryYear  String?
  cardPIN         String?

  // Authorization and redirect information
  redirectUrl       String?
  authorizationMode String?

  // Transaction status and references
  transactionId String?

  // Response fields
  flwStatus   String?
  appFee      Float?
  merchantFee Float?

  // Timestamps
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  paidAt    DateTime?

  // Relations
  restaurant Restaurant  @relation(fields: [restaurantId], references: [id])
  orderItems OrderItem[]
  logistics  Admin?      @relation("LOGISTICS", fields: [logisticsId], references: [id])
  cart       Cart?       @relation(fields: [cartId], references: [id])

  @@index([restaurantId])
  @@index([status])
  @@index([orderNumber])
  @@index([paymentStatus])
  @@index([paymentMethod])
  @@index([txRef])
  @@index([flwRef])
  @@index([transactionId])
  @@index([flwStatus])
  @@index([cartId])
}

// OrderItem model
model OrderItem {
  id          String   @id @default(uuid())
  orderId     String
  productId   String? // Make this optional to allow SetNull
  productName String // Store product name at time of order
  quantity    Float
  unitPrice   Float // Store price at time of order
  subtotal    Float // quantity * unitPrice
  unit        String // Store unit at time of order
  images      String[] // Store images array at time of order
  category    String? // Store category name at time of order
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  order   Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product? @relation(fields: [productId], references: [id], onDelete: SetNull)

  @@index([orderId])
  @@index([productId])
}

// Wallet model for managing user account balances
model Wallet {
  id           String   @id @default(uuid())
  restaurantId String   @unique
  balance      Float    @default(0)
  currency     String   @default("RWF")
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  restaurant   Restaurant          @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  transactions WalletTransaction[]

  @@index([restaurantId])
  @@index([isActive])
}

// Wallet transaction model for tracking all wallet activities
model WalletTransaction {
  id              String                @id @default(uuid())
  walletId        String
  type            WalletTransactionType
  amount          Float // Positive for credit, negative for debit
  previousBalance Float
  newBalance      Float
  description     String?
  reference       String? // Reference to related entity (order, etc.)

  // Integration fields for top-ups
  flwTxRef      String? @unique
  flwRef        String?
  flwStatus     String?
  flwMessage    String?
  paymentMethod String?
  externalTxId  String?

  status   TransactionStatus @default(PENDING)
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@index([walletId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([flwTxRef])
}

model POSSale {
  id            String     @id @default(uuid())
  restaurantId  String
  totalAmount   Float
  paymentMethod String
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  restaurant    Restaurant @relation(fields: [restaurantId], references: [id])
}

// Subscription Plan model
model SubscriptionPlan {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  price       Float
  duration    Int // Duration in days
  features    Json? // Array of features included in the plan
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  subscriptions RestaurantSubscription[]

  @@index([isActive])
  @@index([name])
}

// Restaurant Subscription model
model RestaurantSubscription {
  id            String             @id @default(uuid())
  restaurantId  String
  planId        String
  status        SubscriptionStatus @default(ACTIVE)
  startDate     DateTime           @default(now())
  endDate       DateTime
  autoRenew     Boolean            @default(true)
  paymentMethod PaymentMethod?
  paymentStatus PaymentStatus      @default(PENDING)

  // Payment tracking
  txRef         String? @unique
  flwRef        String?
  transactionId String?
  amountPaid    Float?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  restaurant Restaurant            @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  plan       SubscriptionPlan      @relation(fields: [planId], references: [id])
  payments   SubscriptionPayment[]
  history    SubscriptionHistory[]

  @@index([restaurantId])
  @@index([planId])
  @@index([status])
  @@index([endDate])
}

// Subscription Payment model
model SubscriptionPayment {
  id             String        @id @default(uuid())
  subscriptionId String
  amount         Float
  paymentMethod  PaymentMethod
  paymentStatus  PaymentStatus @default(PENDING)

  // Payment integration fields
  txRef         String? @unique
  flwRef        String?
  transactionId String?
  flwStatus     String?
  flwMessage    String?

  paidAt    DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  subscription RestaurantSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([paymentStatus])
  @@index([txRef])
}

// Subscription History model for tracking changes
model SubscriptionHistory {
  id             String              @id @default(uuid())
  subscriptionId String
  action         SubscriptionAction
  oldStatus      SubscriptionStatus?
  newStatus      SubscriptionStatus?
  oldPlanId      String?
  newPlanId      String?
  reason         String?
  performedBy    String? // Admin ID who performed the action
  createdAt      DateTime            @default(now())

  // Relations
  subscription RestaurantSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([action])
  @@index([createdAt])
}

enum Role {
  FARMER
  RESTAURANT
  ADMIN
  AGGREGATOR
  LOGISTICS
}

enum SubmissionStatus {
  PENDING
  VERIFIED
  APPROVED
  PAID
}

enum FarmerFeedbackStatus {
  PENDING // Farmer hasn't provided feedback yet
  ACCEPTED // Farmer accepted the purchase terms
  REJECTED // Farmer rejected the purchase terms
  EXTENDED // Farmer requested extension/negotiation
}

enum ProductStatus {
  ACTIVE
  INACTIVE
}

// Cart status enum
enum CartStatus {
  ACTIVE // Cart is active and can be modified
  CHECKED_OUT // Cart has been converted to an order
  ABANDONED // Cart has been abandoned (optional for cleanup)
}

// Payment method enum
enum PaymentMethod {
  CASH
  MOBILE_MONEY // Mobile money for Rwanda
  BANK_TRANSFER
  CARD
}

// Payment status enum
enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

// Order status enum
enum OrderStatus {
  PENDING // Order created, waiting for confirmation
  CONFIRMED // Order confirmed, being prepared
  PREPARING // Order is being prepared
  READY // Order ready for pickup/delivery
  IN_TRANSIT // Order out for delivery
  DELIVERED // Order successfully delivered
  CANCELLED // Order cancelled
  REFUNDED // Order refunded
}

// Enum for wallet transaction types
enum WalletTransactionType {
  TOP_UP
  PAYMENT
  REFUND
  ADJUSTMENT // Manual adjustment by admin
  WITHDRAWAL
}

// Enum for transaction status
enum TransactionStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum SubscriptionStatus {
  ACTIVE
  EXPIRED
  CANCELLED
  SUSPENDED
  PENDING
}

enum SubscriptionAction {
  CREATED
  RENEWED
  UPGRADED
  DOWNGRADED
  CANCELLED
  SUSPENDED
  REACTIVATED
  EXPIRED
}

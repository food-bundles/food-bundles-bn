generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Farmer {
  id    String  @id @default(uuid())
  phone String? @unique
  email String? @unique

  province String
  district String
  sector   String
  cell     String
  village  String

  role              Role    @default(FARMER)
  preferredLanguage String? @default("KINY")
  password          String?

  createdAt   DateTime           @default(now())
  updatedAt   DateTime           @updatedAt
  submissions FarmerSubmission[]
}

model Restaurant {
  id    String  @id @default(uuid())
  name  String
  email String  @unique
  phone String? @unique

  province String
  district String
  sector   String
  cell     String
  village  String

  password String
  role     Role   @default(RESTAURANT)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  orders    Order[]
  posSales  POSSale[]
  Cart      Cart[]
  checkouts CHECKOUT[] // Restaurant can have multiple checkouts
  Wallet    Wallet?
}

model FarmerSubmission {
  id                   String                @id @default(uuid())
  farmerId             String
  productName          String
  submittedQty         Float?
  acceptedQty          Float?
  totalAmount          Float?
  categoryId           String?
  status               SubmissionStatus      @default(PENDING)
  farmerFeedbackStatus FarmerFeedbackStatus? @default(PENDING)
  farmerFeedbackAt     DateTime?
  farmerFeedbackNotes  String?
  farmerCounterOffer   Float? // If farmer wants different price
  farmerCounterQty     Float? // If farmer wants different quantity
  feedbackDeadline     DateTime? // Deadline for farmer response
  aggregatorId         String?
  submittedAt          DateTime              @default(now())
  verifiedAt           DateTime?
  approvedAt           DateTime?
  paidAt               DateTime?
  acceptedPrice        Float?
  approvedProductId    String?
  wishedPrice          Float?

  province String
  district String
  sector   String
  cell     String
  village  String

  approvedProduct Product?         @relation(fields: [approvedProductId], references: [id])
  farmer          Farmer           @relation(fields: [farmerId], references: [id])
  aggregator      Admin?           @relation("Aggregator", fields: [aggregatorId], references: [id])
  category        ProductCategory? @relation(fields: [categoryId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Admin {
  id        String   @id @default(uuid())
  username  String
  email     String   @unique
  password  String
  role      Role
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  phone String? @unique

  province String
  district String
  sector   String
  cell     String
  village  String

  aggregatorAssignments FarmerSubmission[] @relation("Aggregator")
  logisticsAssignments  Order[]            @relation("LOGISTICS")
  products              Product[]
  productCategories     ProductCategory[]
}

model Product {
  id                String             @id @default(uuid())
  unitPrice         Float
  purchasePrice     Float
  unit              String
  createdAt         DateTime           @default(now())
  bonus             Int
  createdBy         String
  expiryDate        DateTime?
  images            String[]
  quantity          Float
  sku               String             @unique
  updatedAt         DateTime           @updatedAt
  categoryId        String
  productName       String             @unique
  status            ProductStatus      @default(ACTIVE)
  province          String?
  district          String?
  sector            String?
  cell              String?
  village           String?
  farmerSubmissions FarmerSubmission[]
  orderItems        OrderItem[]
  admin             Admin              @relation(fields: [createdBy], references: [id])
  CartItem          CartItem[]
  category          ProductCategory    @relation(fields: [categoryId], references: [id])
}

model ProductCategory {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String

  // Relations
  admin             Admin              @relation(fields: [createdBy], references: [id])
  products          Product[]
  farmerSubmissions FarmerSubmission[]

  @@index([name])
  @@index([isActive])
}

// Cart schema model - Prisma Schema for Cart Management
model Cart {
  id           String     @id @default(uuid())
  restaurantId String // Foreign key to Restaurant model
  totalAmount  Float      @default(0) // Total amount of all items in cart
  status       CartStatus @default(ACTIVE) // Cart status (ACTIVE, CHECKED_OUT, ABANDONED)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  cartItems  CartItem[] // One cart can have many cart items
  checkout   CHECKOUT? // One cart can have one checkout when proceeding to checkout

  // Indexes for better performance
  @@index([restaurantId])
  @@index([status])
}

// Cart Item model to store individual items in the cart
model CartItem {
  id        String   @id @default(uuid())
  cartId    String // Foreign key to Cart model
  productId String // Foreign key to Product model
  quantity  Float // Quantity of the product
  unitPrice Float // Price per unit at the time of adding to cart
  subtotal  Float // quantity * unitPrice
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Ensure unique product per cart (restaurant can't add same product multiple times)
  @@unique([cartId, productId])
  @@index([cartId])
  @@index([productId])
}

// Enhanced CHECKOUT schema model with fields
model CHECKOUT {
  id            String        @id @default(uuid())
  cartId        String        @unique
  restaurantId  String
  totalAmount   Float
  paymentMethod PaymentMethod
  paymentStatus PaymentStatus @default(PENDING)

  // Billing information
  billingName    String?
  billingEmail   String?
  billingPhone   String?
  billingAddress String?

  // Delivery information
  deliveryProvince String?
  deliveryDistrict String?
  deliverySector   String?
  deliveryCell     String?
  deliveryVillage  String?
  deliveryLocation String?

  // Enhanced Payment Fields
  txRef             String? @unique
  flwRef            String?
  txOrderId         String?
  currency          String? @default("RWF")
  clientIp          String?
  deviceFingerprint String?
  narration         String?

  // Bank transfer specific fields
  transferReference String?
  transferAccount   String?
  transferBank      String?
  accountExpiration DateTime?
  transferNote      String?
  transferAmount    Float?

  // Mobile money specific fields
  network     String? // Network provider (MTN, Airtel, etc.)
  voucher     String? // Voucher code
  paymentCode String? // Payment code for USSD

  // Card payment specific fields - UPDATED SECTION
  cardFirst6Digits String? // First 6 digits of card
  cardLast4Digits  String? // Last 4 digits of card
  cardType         String? // MASTERCARD, VISA, etc.
  cardExpiry       String? // Card expiry (MM/YY format)
  cardCountry      String? // Card issuing country
  authModel        String? // PIN, NOAUTH, OTP, etc.
  encryptionKey    String? // Encryption key for card payments

  // Authorization and redirect information
  redirectUrl          String?
  authorizationMode    String?
  authorizationUrl     String?
  validateInstructions String?

  // Transaction status and references
  transactionId     String?
  paymentReference  String?
  processorResponse String?

  // Response fields - ENHANCED
  flwStatus     String?
  flwMessage    String?
  chargedAmount Float?
  appFee        Float?
  merchantFee   Float?

  // Additional metadata
  paymentPlan String?
  fraudStatus String?
  riskAction  String?
  chargeType  String?
  paymentType String?

  // Customer information from response
  customerId    String?
  customerName  String?
  customerEmail String?
  customerPhone String?

  notes        String?
  deliveryDate DateTime?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  paidAt    DateTime?

  cart       Cart       @relation(fields: [cartId], references: [id], onDelete: Cascade)
  restaurant Restaurant @relation(fields: [restaurantId], references: [id])

  // Owning side of relation
  orderId String? @unique
  order   Order?  @relation(name: "CHECKOUTToOrder", fields: [orderId], references: [id])

  @@index([restaurantId])
  @@index([paymentStatus])
  @@index([paymentMethod])
  @@index([txRef])
  @@index([flwRef])
  @@index([transactionId])
  @@index([flwStatus])
  @@index([fraudStatus])
  @@index([customerId])
}

model Order {
  id           String      @id @default(uuid())
  checkoutId   String?     @unique
  restaurantId String
  logisticsId  String?
  orderNumber  String      @unique
  status       OrderStatus @default(PENDING)
  totalAmount  Float

  notes             String?
  requestedDelivery DateTime?
  estimatedDelivery DateTime?
  actualDelivery    DateTime?

  deliveryProvince String?
  deliveryDistrict String?
  deliverySector   String?
  deliveryCell     String?
  deliveryVillage  String?
  deliveryLocation String?

  paymentMethod    PaymentMethod?
  paymentStatus    PaymentStatus  @default(PENDING)
  paymentReference String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Non-owning side â€” only relation name
  checkout   CHECKOUT?   @relation(name: "CHECKOUTToOrder")
  restaurant Restaurant  @relation(fields: [restaurantId], references: [id])
  orderItems OrderItem[]

  logistics Admin? @relation("LOGISTICS", fields: [logisticsId], references: [id])

  @@index([restaurantId])
  @@index([status])
  @@index([orderNumber])
}

model OrderItem {
  id        String   @id @default(uuid())
  orderId   String
  productId String
  quantity  Float
  unitPrice Float
  order     Order    @relation(fields: [orderId], references: [id])
  product   Product  @relation(fields: [productId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// Wallet model for managing user account balances
model Wallet {
  id           String   @id @default(uuid())
  restaurantId String   @unique
  balance      Float    @default(0)
  currency     String   @default("RWF")
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  restaurant   Restaurant          @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  transactions WalletTransaction[]

  @@index([restaurantId])
  @@index([isActive])
}

// Wallet transaction model for tracking all wallet activities
model WalletTransaction {
  id              String                @id @default(uuid())
  walletId        String
  type            WalletTransactionType
  amount          Float // Positive for credit, negative for debit
  previousBalance Float
  newBalance      Float
  description     String?
  reference       String? // Reference to related entity (checkout, order, etc.)

  // Integration fields for top-ups
  flwTxRef      String? @unique
  flwRef        String?
  flwStatus     String?
  flwMessage    String?
  paymentMethod String?
  externalTxId  String?

  status   TransactionStatus @default(PENDING)
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  wallet Wallet @relation(fields: [walletId], references: [id], onDelete: Cascade)

  @@index([walletId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@index([flwTxRef])
}

model POSSale {
  id            String     @id @default(uuid())
  restaurantId  String
  totalAmount   Float
  paymentMethod String
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  restaurant    Restaurant @relation(fields: [restaurantId], references: [id])
}

enum Role {
  FARMER
  RESTAURANT
  ADMIN
  AGGREGATOR
  LOGISTICS
}

enum SubmissionStatus {
  PENDING
  VERIFIED
  APPROVED
  PAID
}

enum FarmerFeedbackStatus {
  PENDING // Farmer hasn't provided feedback yet
  ACCEPTED // Farmer accepted the purchase terms
  REJECTED // Farmer rejected the purchase terms
  EXTENDED // Farmer requested extension/negotiation
}

enum ProductStatus {
  ACTIVE
  INACTIVE
}

// Cart status enum
enum CartStatus {
  ACTIVE // Cart is active and can be modified
  CHECKED_OUT // Cart has been converted to an order
  ABANDONED // Cart has been abandoned (optional for cleanup)
}

// Payment method enum
enum PaymentMethod {
  CASH
  MOBILE_MONEY // Mobile money for Rwanda
  BANK_TRANSFER
  CARD
}

// Payment status enum
enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

// Order status enum
enum OrderStatus {
  PENDING // Order created, waiting for confirmation
  CONFIRMED // Order confirmed, being prepared
  PREPARING // Order is being prepared
  READY // Order ready for pickup/delivery
  IN_TRANSIT // Order out for delivery
  DELIVERED // Order successfully delivered
  CANCELLED // Order cancelled
  REFUNDED // Order refunded
}

// Enum for wallet transaction types
enum WalletTransactionType {
  TOP_UP 
  PAYMENT 
  REFUND 
  ADJUSTMENT // Manual adjustment by admin
  WITHDRAWAL 
}

// Enum for transaction status
enum TransactionStatus {
  PENDING 
  PROCESSING 
  COMPLETED 
  FAILED 
  CANCELLED 
  REFUNDED
}
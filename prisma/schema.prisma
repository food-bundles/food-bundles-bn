generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Farmer {
  id    String  @id @default(uuid())
  phone String? @unique
  email String? @unique

  location String
  province String?
  district String?
  sector   String?
  cell     String?
  village  String?

  role        Role               @default(FARMER)
  password    String?
  createdAt   DateTime           @default(now())
  submissions FarmerSubmission[]
}

model Restaurant {
  id    String  @id @default(uuid())
  name  String
  email String  @unique
  phone String? @unique

  location String
  province String?
  district String?
  sector   String?
  cell     String?
  village  String?

  password  String
  role      Role     @default(RESTAURANT)
  createdAt DateTime @default(now())

  // Relations
  orders    Order[]
  posSales  POSSale[]
  Cart      Cart[]
  checkouts CHECKOUT[] // Restaurant can have multiple checkouts
}

model FarmerSubmission {
  id                   String                @id @default(uuid())
  farmerId             String
  productName          String
  submittedQty         Float?
  acceptedQty          Float?
  totalAmount          Float?
  category             ProductCategory       @default(OTHER)
  status               SubmissionStatus      @default(PENDING)
  farmerFeedbackStatus FarmerFeedbackStatus? @default(PENDING)
  farmerFeedbackAt     DateTime?
  farmerFeedbackNotes  String?
  farmerCounterOffer   Float? // If farmer wants different price
  farmerCounterQty     Float? // If farmer wants different quantity
  feedbackDeadline     DateTime? // Deadline for farmer response
  aggregatorId         String?
  submittedAt          DateTime              @default(now())
  verifiedAt           DateTime?
  approvedAt           DateTime?
  paidAt               DateTime?
  acceptedPrice        Float?
  approvedProductId    String?
  wishedPrice          Float?

  province String?
  district String?
  sector   String?
  cell     String?
  village  String?

  approvedProduct Product? @relation(fields: [approvedProductId], references: [id])
  farmer          Farmer   @relation(fields: [farmerId], references: [id])
  aggregator      Admin?   @relation("Aggregator", fields: [aggregatorId], references: [id])
}

model Admin {
  id        String   @id @default(uuid())
  username  String
  email     String   @unique
  password  String
  role      Role
  createdAt DateTime @default(now())
  phone     String?  @unique

  province String?
  district String?
  sector   String?
  cell     String?
  village  String?

  aggregatorAssignments FarmerSubmission[] @relation("Aggregator")
  products              Product[]
}

model Product {
  id                String             @id @default(uuid())
  unitPrice         Float
  unit              String
  createdAt         DateTime           @default(now())
  bonus             Int
  createdBy         String
  expiryDate        DateTime?
  images            String[]
  quantity          Float
  sku               String             @unique
  updatedAt         DateTime           @updatedAt
  category          ProductCategory
  productName       String
  status            ProductStatus      @default(ACTIVE)
  province          String?
  district          String?
  sector            String?
  cell              String?
  village           String?
  farmerSubmissions FarmerSubmission[]
  orderItems        OrderItem[]
  admin             Admin              @relation(fields: [createdBy], references: [id])
  CartItem          CartItem[]
}

// Cart schema model - Prisma Schema for Cart Management
model Cart {
  id           String     @id @default(uuid())
  restaurantId String // Foreign key to Restaurant model
  totalAmount  Float      @default(0) // Total amount of all items in cart
  status       CartStatus @default(ACTIVE) // Cart status (ACTIVE, CHECKED_OUT, ABANDONED)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // Relations
  restaurant Restaurant @relation(fields: [restaurantId], references: [id], onDelete: Cascade)
  cartItems  CartItem[] // One cart can have many cart items
  checkout   CHECKOUT? // One cart can have one checkout when proceeding to checkout

  // Indexes for better performance
  @@index([restaurantId])
  @@index([status])
}

// Cart Item model to store individual items in the cart
model CartItem {
  id        String   @id @default(uuid())
  cartId    String // Foreign key to Cart model
  productId String // Foreign key to Product model
  quantity  Float // Quantity of the product
  unitPrice Float // Price per unit at the time of adding to cart
  subtotal  Float // quantity * unitPrice
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  cart    Cart    @relation(fields: [cartId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  // Ensure unique product per cart (restaurant can't add same product multiple times)
  @@unique([cartId, productId])
  @@index([cartId])
  @@index([productId])
}

// CHECKOUT schema model
model CHECKOUT {
  id            String        @id @default(uuid())
  cartId        String        @unique
  restaurantId  String
  totalAmount   Float
  paymentMethod PaymentMethod
  paymentStatus PaymentStatus @default(PENDING)

  billingName    String?
  billingEmail   String?
  billingPhone   String?
  billingAddress String?

  deliveryProvince String?
  deliveryDistrict String?
  deliverySector   String?
  deliveryCell     String?
  deliveryVillage  String?
  deliveryLocation String?

  paymentReference String?
  transactionId    String?

  notes        String?
  deliveryDate DateTime?

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  paidAt    DateTime?

  cart       Cart       @relation(fields: [cartId], references: [id], onDelete: Cascade)
  restaurant Restaurant @relation(fields: [restaurantId], references: [id])

  // Owning side of relation
  orderId String? @unique
  order   Order?  @relation(name: "CHECKOUTToOrder", fields: [orderId], references: [id])

  @@index([restaurantId])
  @@index([paymentStatus])
  @@index([paymentMethod])
}

model Order {
  id           String      @id @default(uuid())
  checkoutId   String?     @unique
  restaurantId String
  orderNumber  String      @unique
  status       OrderStatus @default(PENDING)
  totalAmount  Float

  notes             String?
  requestedDelivery DateTime?
  estimatedDelivery DateTime?
  actualDelivery    DateTime?

  deliveryProvince String?
  deliveryDistrict String?
  deliverySector   String?
  deliveryCell     String?
  deliveryVillage  String?
  deliveryLocation String?

  paymentMethod    PaymentMethod?
  paymentStatus    PaymentStatus  @default(PENDING)
  paymentReference String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Non-owning side â€” only relation name
  checkout   CHECKOUT?   @relation(name: "CHECKOUTToOrder")
  restaurant Restaurant  @relation(fields: [restaurantId], references: [id])
  orderItems OrderItem[]

  @@index([restaurantId])
  @@index([status])
  @@index([orderNumber])
}

model OrderItem {
  id        String  @id @default(uuid())
  orderId   String
  productId String
  quantity  Float
  unitPrice Float
  order     Order   @relation(fields: [orderId], references: [id])
  product   Product @relation(fields: [productId], references: [id])
}

model POSSale {
  id            String     @id @default(uuid())
  restaurantId  String
  totalAmount   Float
  paymentMethod String
  createdAt     DateTime   @default(now())
  restaurant    Restaurant @relation(fields: [restaurantId], references: [id])
}

enum Role {
  FARMER
  RESTAURANT
  ADMIN
  AGGREGATOR
}

enum SubmissionStatus {
  PENDING
  VERIFIED
  APPROVED
  PAID
}

enum FarmerFeedbackStatus {
  PENDING // Farmer hasn't provided feedback yet
  ACCEPTED // Farmer accepted the purchase terms
  REJECTED // Farmer rejected the purchase terms
  EXTENDED // Farmer requested extension/negotiation
}

enum ProductCategory {
  VEGETABLES
  FRUITS
  GRAINS
  TUBERS
  LEGUMES
  HERBS_SPICES
  OTHER
}

enum ProductStatus {
  ACTIVE
  INACTIVE
}

// Cart status enum
enum CartStatus {
  ACTIVE // Cart is active and can be modified
  CHECKED_OUT // Cart has been converted to an order
  ABANDONED // Cart has been abandoned (optional for cleanup)
}

// Payment method enum
enum PaymentMethod {
  CASH
  MOBILE_MONEY // PayPack for Rwanda
  BANK_TRANSFER
  CARD
}

// Payment status enum
enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

// Order status enum
enum OrderStatus {
  PENDING // Order created, waiting for confirmation
  CONFIRMED // Order confirmed, being prepared
  PREPARING // Order is being prepared
  READY // Order ready for pickup/delivery
  IN_TRANSIT // Order out for delivery
  DELIVERED // Order successfully delivered
  CANCELLED // Order cancelled
  REFUNDED // Order refunded
}
